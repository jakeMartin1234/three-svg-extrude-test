!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e(require("THREE")):"function"==typeof define&&define.amd?define(["THREE"],e):"object"==typeof exports?exports["three-svg-extrude"]=e(require("THREE")):t["three-svg-extrude"]=e(t.THREE)}(this,(t=>(()=>{"use strict";var e={824:e=>{e.exports=t}},r={};function n(t){var o=r[t];if(void 0!==o)return o.exports;var i=r[t]={exports:{}};return e[t](i,i.exports,n),i.exports}n.d=(t,e)=>{for(var r in e)n.o(e,r)&&!n.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:e[r]})},n.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),n.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var o={};return(()=>{n.r(o),n.d(o,{svgToExtrudedGeometry:()=>s});var t=n(824);const e=t.SRGBColorSpace;class r extends t.Loader{constructor(t){super(t),this.defaultDPI=90,this.defaultUnit="px"}load(e,r,n,o){const i=this,s=new t.FileLoader(i.manager);s.setPath(i.path),s.setRequestHeader(i.requestHeader),s.setWithCredentials(i.withCredentials),s.load(e,(function(t){try{r(i.parse(t))}catch(t){o?o(t):console.error(t),i.manager.itemError(e)}}),n,o)}parse(r){const n=this;function o(t,e,r,n,o,s,a,c){if(0==e||0==r)return void t.lineTo(c.x,c.y);n=n*Math.PI/180,e=Math.abs(e),r=Math.abs(r);const l=(a.x-c.x)/2,u=(a.y-c.y)/2,f=Math.cos(n)*l+Math.sin(n)*u,y=-Math.sin(n)*l+Math.cos(n)*u;let h=e*e,p=r*r;const d=f*f,m=y*y,b=d/h+m/p;if(b>1){const t=Math.sqrt(b);h=(e*=t)*e,p=(r*=t)*r}const g=h*m+p*d,x=(h*p-g)/g;let A=Math.sqrt(Math.max(0,x));o===s&&(A=-A);const v=A*e*y/r,w=-A*r*f/e,k=Math.cos(n)*v-Math.sin(n)*w+(a.x+c.x)/2,T=Math.sin(n)*v+Math.cos(n)*w+(a.y+c.y)/2,M=i(1,0,(f-v)/e,(y-w)/r),E=i((f-v)/e,(y-w)/r,(-f-v)/e,(-y-w)/r)%(2*Math.PI);t.currentPath.absellipse(k,T,e,r,M,M+E,0===s,n)}function i(t,e,r,n){const o=t*r+e*n,i=Math.sqrt(t*t+e*e)*Math.sqrt(r*r+n*n);let s=Math.acos(Math.max(-1,Math.min(1,o/i)));return t*n-e*r<0&&(s=-s),s}function s(t,e){e=Object.assign({},e);let r={};if(t.hasAttribute("class")){const e=t.getAttribute("class").split(/\s/).filter(Boolean).map((t=>t.trim()));for(let t=0;t<e.length;t++)r=Object.assign(r,b["."+e[t]])}function n(n,o,i){void 0===i&&(i=function(t){return t.startsWith("url")&&console.warn("SVGLoader: url access in attributes is not implemented."),t}),t.hasAttribute(n)&&(e[o]=i(t.getAttribute(n))),r[n]&&(e[o]=i(r[n])),t.style&&""!==t.style[n]&&(e[o]=i(t.style[n]))}function o(t){return Math.max(0,Math.min(1,f(t)))}function i(t){return Math.max(0,f(t))}return t.hasAttribute("id")&&(r=Object.assign(r,b["#"+t.getAttribute("id")])),n("fill","fill"),n("fill-opacity","fillOpacity",o),n("fill-rule","fillRule"),n("opacity","opacity",o),n("stroke","stroke"),n("stroke-opacity","strokeOpacity",o),n("stroke-width","strokeWidth",i),n("stroke-linejoin","strokeLineJoin"),n("stroke-linecap","strokeLineCap"),n("stroke-miterlimit","strokeMiterLimit",i),n("visibility","visibility"),e}function a(t,e){return t-(e-t)}function c(t,e,r){if("string"!=typeof t)throw new TypeError("Invalid input: "+typeof t);const n={SEPARATOR:/[ \t\r\n\,.\-+]/,WHITESPACE:/[ \t\r\n]/,DIGIT:/[\d]/,SIGN:/[-+]/,POINT:/\./,COMMA:/,/,EXP:/e/i,FLAGS:/[01]/};let o=0,i=!0,s="",a="";const c=[];function l(t,e,r){const n=new SyntaxError('Unexpected character "'+t+'" at index '+e+".");throw n.partial=r,n}function u(){""!==s&&(""===a?c.push(Number(s)):c.push(Number(s)*Math.pow(10,Number(a)))),s="",a=""}let f;const y=t.length;for(let h=0;h<y;h++)if(f=t[h],Array.isArray(e)&&e.includes(c.length%r)&&n.FLAGS.test(f))o=1,s=f,u();else{if(0===o){if(n.WHITESPACE.test(f))continue;if(n.DIGIT.test(f)||n.SIGN.test(f)){o=1,s=f;continue}if(n.POINT.test(f)){o=2,s=f;continue}n.COMMA.test(f)&&(i&&l(f,h,c),i=!0)}if(1===o){if(n.DIGIT.test(f)){s+=f;continue}if(n.POINT.test(f)){s+=f,o=2;continue}if(n.EXP.test(f)){o=3;continue}n.SIGN.test(f)&&1===s.length&&n.SIGN.test(s[0])&&l(f,h,c)}if(2===o){if(n.DIGIT.test(f)){s+=f;continue}if(n.EXP.test(f)){o=3;continue}n.POINT.test(f)&&"."===s[s.length-1]&&l(f,h,c)}if(3===o){if(n.DIGIT.test(f)){a+=f;continue}if(n.SIGN.test(f)){if(""===a){a+=f;continue}1===a.length&&n.SIGN.test(a)&&l(f,h,c)}}n.WHITESPACE.test(f)?(u(),o=0,i=!1):n.COMMA.test(f)?(u(),o=0,i=!0):n.SIGN.test(f)?(u(),o=1,s=f):n.POINT.test(f)?(u(),o=2,s=f):l(f,h,c)}return u(),c}const l=["mm","cm","in","pt","pc","px"],u={mm:{mm:1,cm:.1,in:1/25.4,pt:72/25.4,pc:6/25.4,px:-1},cm:{mm:10,cm:1,in:1/2.54,pt:72/2.54,pc:6/2.54,px:-1},in:{mm:25.4,cm:2.54,in:1,pt:72,pc:6,px:-1},pt:{mm:25.4/72,cm:2.54/72,in:1/72,pt:1,pc:6/72,px:-1},pc:{mm:25.4/6,cm:2.54/6,in:1/6,pt:12,pc:1,px:-1},px:{px:1}};function f(t){let e,r="px";if("string"==typeof t||t instanceof String)for(let e=0,n=l.length;e<n;e++){const n=l[e];if(t.endsWith(n)){r=n,t=t.substring(0,t.length-n.length);break}}return"px"===r&&"px"!==n.defaultUnit?e=u.in[n.defaultUnit]/n.defaultDPI:(e=u[r][n.defaultUnit],e<0&&(e=u[r].in*n.defaultDPI)),e*parseFloat(t)}function y(t){const e=t.elements;return e[0]*e[4]-e[1]*e[3]<0}function h(t){const e=t.elements,r=e[0]*e[3]+e[1]*e[4];if(0===r)return!1;const n=p(t),o=d(t);return Math.abs(r/(n*o))>Number.EPSILON}function p(t){const e=t.elements;return Math.sqrt(e[0]*e[0]+e[1]*e[1])}function d(t){const e=t.elements;return Math.sqrt(e[3]*e[3]+e[4]*e[4])}const m=[],b={},g=[],x=new t.Matrix3,A=new t.Matrix3,v=new t.Matrix3,w=new t.Matrix3,k=new t.Vector2,T=new t.Vector3,M=new t.Matrix3,E=(new DOMParser).parseFromString(r,"image/svg+xml");return function r(n,i){if(1!==n.nodeType)return;const l=function(e){if(!(e.hasAttribute("transform")||"use"===e.nodeName&&(e.hasAttribute("x")||e.hasAttribute("y"))))return null;const r=function(e){const r=new t.Matrix3,n=x;if("use"===e.nodeName&&(e.hasAttribute("x")||e.hasAttribute("y"))){const t=f(e.getAttribute("x")),n=f(e.getAttribute("y"));r.translate(t,n)}if(e.hasAttribute("transform")){const t=e.getAttribute("transform").split(")");for(let e=t.length-1;e>=0;e--){const o=t[e].trim();if(""===o)continue;const i=o.indexOf("("),s=o.length;if(i>0&&i<s){const t=o.slice(0,i),e=c(o.slice(i+1));switch(n.identity(),t){case"translate":if(e.length>=1){const t=e[0];let r=0;e.length>=2&&(r=e[1]),n.translate(t,r)}break;case"rotate":if(e.length>=1){let t=0,r=0,o=0;t=e[0]*Math.PI/180,e.length>=3&&(r=e[1],o=e[2]),A.makeTranslation(-r,-o),v.makeRotation(t),w.multiplyMatrices(v,A),A.makeTranslation(r,o),n.multiplyMatrices(A,w)}break;case"scale":if(e.length>=1){const t=e[0];let r=t;e.length>=2&&(r=e[1]),n.scale(t,r)}break;case"skewX":1===e.length&&n.set(1,Math.tan(e[0]*Math.PI/180),0,0,1,0,0,0,1);break;case"skewY":1===e.length&&n.set(1,0,0,Math.tan(e[0]*Math.PI/180),1,0,0,0,1);break;case"matrix":6===e.length&&n.set(e[0],e[2],e[4],e[1],e[3],e[5],0,0,1)}}r.premultiply(n)}}return r}(e);return g.length>0&&r.premultiply(g[g.length-1]),M.copy(r),g.push(r),r}(n);let u=!1,E=null;switch(n.nodeName){case"svg":case"g":i=s(n,i);break;case"style":!function(t){if(t.sheet&&t.sheet.cssRules&&t.sheet.cssRules.length)for(let e=0;e<t.sheet.cssRules.length;e++){const r=t.sheet.cssRules[e];if(1!==r.type)continue;const n=r.selectorText.split(/,/gm).filter(Boolean).map((t=>t.trim()));for(let t=0;t<n.length;t++){const e=Object.fromEntries(Object.entries(r.style).filter((([,t])=>""!==t)));b[n[t]]=Object.assign(b[n[t]]||{},e)}}}(n);break;case"path":i=s(n,i),n.hasAttribute("d")&&(E=function(e){const r=new t.ShapePath,n=new t.Vector2,i=new t.Vector2,s=new t.Vector2;let l=!0,u=!1;const f=e.getAttribute("d");if(""===f||"none"===f)return null;const y=f.match(/[a-df-z][^a-df-z]*/gi);for(let t=0,e=y.length;t<e;t++){const e=y[t],f=e.charAt(0),h=e.slice(1).trim();let p;switch(!0===l&&(u=!0,l=!1),f){case"M":p=c(h);for(let t=0,e=p.length;t<e;t+=2)n.x=p[t+0],n.y=p[t+1],i.x=n.x,i.y=n.y,0===t?r.moveTo(n.x,n.y):r.lineTo(n.x,n.y),0===t&&s.copy(n);break;case"H":p=c(h);for(let t=0,e=p.length;t<e;t++)n.x=p[t],i.x=n.x,i.y=n.y,r.lineTo(n.x,n.y),0===t&&!0===u&&s.copy(n);break;case"V":p=c(h);for(let t=0,e=p.length;t<e;t++)n.y=p[t],i.x=n.x,i.y=n.y,r.lineTo(n.x,n.y),0===t&&!0===u&&s.copy(n);break;case"L":p=c(h);for(let t=0,e=p.length;t<e;t+=2)n.x=p[t+0],n.y=p[t+1],i.x=n.x,i.y=n.y,r.lineTo(n.x,n.y),0===t&&!0===u&&s.copy(n);break;case"C":p=c(h);for(let t=0,e=p.length;t<e;t+=6)r.bezierCurveTo(p[t+0],p[t+1],p[t+2],p[t+3],p[t+4],p[t+5]),i.x=p[t+2],i.y=p[t+3],n.x=p[t+4],n.y=p[t+5],0===t&&!0===u&&s.copy(n);break;case"S":p=c(h);for(let t=0,e=p.length;t<e;t+=4)r.bezierCurveTo(a(n.x,i.x),a(n.y,i.y),p[t+0],p[t+1],p[t+2],p[t+3]),i.x=p[t+0],i.y=p[t+1],n.x=p[t+2],n.y=p[t+3],0===t&&!0===u&&s.copy(n);break;case"Q":p=c(h);for(let t=0,e=p.length;t<e;t+=4)r.quadraticCurveTo(p[t+0],p[t+1],p[t+2],p[t+3]),i.x=p[t+0],i.y=p[t+1],n.x=p[t+2],n.y=p[t+3],0===t&&!0===u&&s.copy(n);break;case"T":p=c(h);for(let t=0,e=p.length;t<e;t+=2){const e=a(n.x,i.x),o=a(n.y,i.y);r.quadraticCurveTo(e,o,p[t+0],p[t+1]),i.x=e,i.y=o,n.x=p[t+0],n.y=p[t+1],0===t&&!0===u&&s.copy(n)}break;case"A":p=c(h,[3,4],7);for(let t=0,e=p.length;t<e;t+=7){if(p[t+5]==n.x&&p[t+6]==n.y)continue;const e=n.clone();n.x=p[t+5],n.y=p[t+6],i.x=n.x,i.y=n.y,o(r,p[t],p[t+1],p[t+2],p[t+3],p[t+4],e,n),0===t&&!0===u&&s.copy(n)}break;case"m":p=c(h);for(let t=0,e=p.length;t<e;t+=2)n.x+=p[t+0],n.y+=p[t+1],i.x=n.x,i.y=n.y,0===t?r.moveTo(n.x,n.y):r.lineTo(n.x,n.y),0===t&&s.copy(n);break;case"h":p=c(h);for(let t=0,e=p.length;t<e;t++)n.x+=p[t],i.x=n.x,i.y=n.y,r.lineTo(n.x,n.y),0===t&&!0===u&&s.copy(n);break;case"v":p=c(h);for(let t=0,e=p.length;t<e;t++)n.y+=p[t],i.x=n.x,i.y=n.y,r.lineTo(n.x,n.y),0===t&&!0===u&&s.copy(n);break;case"l":p=c(h);for(let t=0,e=p.length;t<e;t+=2)n.x+=p[t+0],n.y+=p[t+1],i.x=n.x,i.y=n.y,r.lineTo(n.x,n.y),0===t&&!0===u&&s.copy(n);break;case"c":p=c(h);for(let t=0,e=p.length;t<e;t+=6)r.bezierCurveTo(n.x+p[t+0],n.y+p[t+1],n.x+p[t+2],n.y+p[t+3],n.x+p[t+4],n.y+p[t+5]),i.x=n.x+p[t+2],i.y=n.y+p[t+3],n.x+=p[t+4],n.y+=p[t+5],0===t&&!0===u&&s.copy(n);break;case"s":p=c(h);for(let t=0,e=p.length;t<e;t+=4)r.bezierCurveTo(a(n.x,i.x),a(n.y,i.y),n.x+p[t+0],n.y+p[t+1],n.x+p[t+2],n.y+p[t+3]),i.x=n.x+p[t+0],i.y=n.y+p[t+1],n.x+=p[t+2],n.y+=p[t+3],0===t&&!0===u&&s.copy(n);break;case"q":p=c(h);for(let t=0,e=p.length;t<e;t+=4)r.quadraticCurveTo(n.x+p[t+0],n.y+p[t+1],n.x+p[t+2],n.y+p[t+3]),i.x=n.x+p[t+0],i.y=n.y+p[t+1],n.x+=p[t+2],n.y+=p[t+3],0===t&&!0===u&&s.copy(n);break;case"t":p=c(h);for(let t=0,e=p.length;t<e;t+=2){const e=a(n.x,i.x),o=a(n.y,i.y);r.quadraticCurveTo(e,o,n.x+p[t+0],n.y+p[t+1]),i.x=e,i.y=o,n.x=n.x+p[t+0],n.y=n.y+p[t+1],0===t&&!0===u&&s.copy(n)}break;case"a":p=c(h,[3,4],7);for(let t=0,e=p.length;t<e;t+=7){if(0==p[t+5]&&0==p[t+6])continue;const e=n.clone();n.x+=p[t+5],n.y+=p[t+6],i.x=n.x,i.y=n.y,o(r,p[t],p[t+1],p[t+2],p[t+3],p[t+4],e,n),0===t&&!0===u&&s.copy(n)}break;case"Z":case"z":r.currentPath.autoClose=!0,r.currentPath.curves.length>0&&(n.copy(s),r.currentPath.currentPoint.copy(n),l=!0);break;default:console.warn(e)}u=!1}return r}(n));break;case"rect":i=s(n,i),E=function(e){const r=f(e.getAttribute("x")||0),n=f(e.getAttribute("y")||0),o=f(e.getAttribute("rx")||e.getAttribute("ry")||0),i=f(e.getAttribute("ry")||e.getAttribute("rx")||0),s=f(e.getAttribute("width")),a=f(e.getAttribute("height")),c=.448084975506,l=new t.ShapePath;return l.moveTo(r+o,n),l.lineTo(r+s-o,n),(0!==o||0!==i)&&l.bezierCurveTo(r+s-o*c,n,r+s,n+i*c,r+s,n+i),l.lineTo(r+s,n+a-i),(0!==o||0!==i)&&l.bezierCurveTo(r+s,n+a-i*c,r+s-o*c,n+a,r+s-o,n+a),l.lineTo(r+o,n+a),(0!==o||0!==i)&&l.bezierCurveTo(r+o*c,n+a,r,n+a-i*c,r,n+a-i),l.lineTo(r,n+i),(0!==o||0!==i)&&l.bezierCurveTo(r,n+i*c,r+o*c,n,r+o,n),l}(n);break;case"polygon":i=s(n,i),E=function(e){const r=new t.ShapePath;let n=0;return e.getAttribute("points").replace(/([+-]?\d*\.?\d+(?:e[+-]?\d+)?)(?:,|\s)([+-]?\d*\.?\d+(?:e[+-]?\d+)?)/g,(function(t,e,o){const i=f(e),s=f(o);0===n?r.moveTo(i,s):r.lineTo(i,s),n++})),r.currentPath.autoClose=!0,r}(n);break;case"polyline":i=s(n,i),E=function(e){const r=new t.ShapePath;let n=0;return e.getAttribute("points").replace(/([+-]?\d*\.?\d+(?:e[+-]?\d+)?)(?:,|\s)([+-]?\d*\.?\d+(?:e[+-]?\d+)?)/g,(function(t,e,o){const i=f(e),s=f(o);0===n?r.moveTo(i,s):r.lineTo(i,s),n++})),r.currentPath.autoClose=!1,r}(n);break;case"circle":i=s(n,i),E=function(e){const r=f(e.getAttribute("cx")||0),n=f(e.getAttribute("cy")||0),o=f(e.getAttribute("r")||0),i=new t.Path;i.absarc(r,n,o,0,2*Math.PI);const s=new t.ShapePath;return s.subPaths.push(i),s}(n);break;case"ellipse":i=s(n,i),E=function(e){const r=f(e.getAttribute("cx")||0),n=f(e.getAttribute("cy")||0),o=f(e.getAttribute("rx")||0),i=f(e.getAttribute("ry")||0),s=new t.Path;s.absellipse(r,n,o,i,0,2*Math.PI);const a=new t.ShapePath;return a.subPaths.push(s),a}(n);break;case"line":i=s(n,i),E=function(e){const r=f(e.getAttribute("x1")||0),n=f(e.getAttribute("y1")||0),o=f(e.getAttribute("x2")||0),i=f(e.getAttribute("y2")||0),s=new t.ShapePath;return s.moveTo(r,n),s.lineTo(o,i),s.currentPath.autoClose=!1,s}(n);break;case"defs":u=!0;break;case"use":i=s(n,i);const e=(n.getAttributeNS("http://www.w3.org/1999/xlink","href")||"").substring(1),l=n.viewportElement.getElementById(e);l?r(l,i):console.warn("SVGLoader: 'use node' references non-existent node id: "+e)}E&&(void 0!==i.fill&&"none"!==i.fill&&E.color.setStyle(i.fill,e),function(e,r){function n(t){T.set(t.x,t.y,1).applyMatrix3(r),t.set(T.x,T.y)}function o(e){const n=e.xRadius,o=e.yRadius,i=Math.cos(e.aRotation),s=Math.sin(e.aRotation),a=new t.Vector3(n*i,n*s,0),c=new t.Vector3(-o*s,o*i,0),l=a.applyMatrix3(r),u=c.applyMatrix3(r),f=x.set(l.x,u.x,0,l.y,u.y,0,0,0,1),h=A.copy(f).invert(),p=v.copy(h).transpose().multiply(h).elements,d=function(t,e,r){let n,o,i,s,a;const c=t+r,l=t-r,u=Math.sqrt(l*l+4*e*e);return c>0?(n=.5*(c+u),a=1/n,o=t*a*r-e*a*e):c<0?o=.5*(c-u):(n=.5*u,o=-.5*u),i=l>0?l+u:l-u,Math.abs(i)>2*Math.abs(e)?(a=-2*e/i,s=1/Math.sqrt(1+a*a),i=a*s):0===Math.abs(e)?(i=1,s=0):(a=-.5*i/e,i=1/Math.sqrt(1+a*a),s=a*i),l>0&&(a=i,i=-s,s=a),{rt1:n,rt2:o,cs:i,sn:s}}(p[0],p[1],p[4]),m=Math.sqrt(d.rt1),b=Math.sqrt(d.rt2);if(e.xRadius=1/m,e.yRadius=1/b,e.aRotation=Math.atan2(d.sn,d.cs),!((e.aEndAngle-e.aStartAngle)%(2*Math.PI)<Number.EPSILON)){const n=A.set(m,0,0,0,b,0,0,0,1),o=v.set(d.cs,d.sn,0,-d.sn,d.cs,0,0,0,1),i=n.multiply(o).multiply(f),s=e=>{const{x:r,y:n}=new t.Vector3(Math.cos(e),Math.sin(e),0).applyMatrix3(i);return Math.atan2(n,r)};e.aStartAngle=s(e.aStartAngle),e.aEndAngle=s(e.aEndAngle),y(r)&&(e.aClockwise=!e.aClockwise)}}function i(t){const e=p(r),n=d(r);t.xRadius*=e,t.yRadius*=n;const o=e>Number.EPSILON?Math.atan2(r.elements[1],r.elements[0]):Math.atan2(-r.elements[3],r.elements[4]);t.aRotation+=o,y(r)&&(t.aStartAngle*=-1,t.aEndAngle*=-1,t.aClockwise=!t.aClockwise)}const s=e.subPaths;for(let t=0,e=s.length;t<e;t++){const e=s[t].curves;for(let t=0;t<e.length;t++){const s=e[t];s.isLineCurve?(n(s.v1),n(s.v2)):s.isCubicBezierCurve?(n(s.v0),n(s.v1),n(s.v2),n(s.v3)):s.isQuadraticBezierCurve?(n(s.v0),n(s.v1),n(s.v2)):s.isEllipseCurve&&(k.set(s.aX,s.aY),n(k),s.aX=k.x,s.aY=k.y,h(r)?o(s):i(s))}}}(E,M),m.push(E),E.userData={node:n,style:i});const S=n.childNodes;for(let t=0;t<S.length;t++){const e=S[t];u&&"style"!==e.nodeName&&"defs"!==e.nodeName||r(e,i)}l&&(g.pop(),g.length>0?M.copy(g[g.length-1]):M.identity())}(E.documentElement,{fill:"#000",fillOpacity:1,strokeOpacity:1,strokeWidth:1,strokeLineJoin:"miter",strokeLineCap:"butt",strokeMiterLimit:4}),{paths:m,xml:E.documentElement}}static createShapes(e){const r=999999999,n={loc:0,t:0};function o(t,e,r,o){const s=t.x,a=e.x,c=r.x,l=o.x,u=t.y,f=e.y,y=r.y,h=o.y,p=(l-c)*(u-y)-(h-y)*(s-c),d=(h-y)*(a-s)-(l-c)*(f-u),m=p/d,b=((a-s)*(u-y)-(f-u)*(s-c))/d;if(0===d&&0!==p||m<=0||m>=1||b<0||b>1)return null;if(0===p&&0===d){for(let c=0;c<2;c++){if(i(0===c?r:o,t,e),0==n.loc){const t=0===c?r:o;return{x:t.x,y:t.y,t:n.t}}if(2==n.loc)return{x:+(s+n.t*(a-s)).toPrecision(10),y:+(u+n.t*(f-u)).toPrecision(10),t:n.t}}return null}for(let s=0;s<2;s++)if(i(0===s?r:o,t,e),0==n.loc){const t=0===s?r:o;return{x:t.x,y:t.y,t:n.t}}return{x:+(s+m*(a-s)).toPrecision(10),y:+(u+m*(f-u)).toPrecision(10),t:m}}function i(t,e,r){const o=r.x-e.x,i=r.y-e.y,s=t.x-e.x,a=t.y-e.y,c=o*a-s*i;if(t.x===e.x&&t.y===e.y)return n.loc=0,void(n.t=0);if(t.x===r.x&&t.y===r.y)return n.loc=1,void(n.t=1);if(c<-Number.EPSILON)return void(n.loc=3);if(c>Number.EPSILON)return void(n.loc=4);if(o*s<0||i*a<0)return void(n.loc=5);if(Math.sqrt(o*o+i*i)<Math.sqrt(s*s+a*a))return void(n.loc=6);let l;l=0!==o?s/o:a/i,n.loc=2,n.t=l}let s=r,a=-999999999,c=e.subPaths.map((e=>{const n=e.getPoints();let o=-999999999,i=r,c=-999999999,l=r;for(let t=0;t<n.length;t++){const e=n[t];e.y>o&&(o=e.y),e.y<i&&(i=e.y),e.x>c&&(c=e.x),e.x<l&&(l=e.x)}return a<=c&&(a=c+1),s>=l&&(s=l-1),{curves:e.curves,points:n,isCW:t.ShapeUtils.isClockWise(n),identifier:-1,boundingBox:new t.Box2(new t.Vector2(l,i),new t.Vector2(c,o))}}));c=c.filter((t=>t.points.length>1));for(let t=0;t<c.length;t++)c[t].identifier=t;const l=c.map((r=>function(e,r,n,i,s){null!=s&&""!==s||(s="nonzero");const a=new t.Vector2;e.boundingBox.getCenter(a);const c=function(e,r,n){const i=new t.Vector2;r.getCenter(i);const s=[];return n.forEach((r=>{r.boundingBox.containsPoint(i)&&function(e,r){const n=[],i=[];for(let s=1;s<e.length;s++){const a=e[s-1],c=e[s];for(let e=1;e<r.length;e++){const s=o(a,c,r[e-1],r[e]);null!==s&&void 0===n.find((t=>t.t<=s.t+Number.EPSILON&&t.t>=s.t-Number.EPSILON))&&(n.push(s),i.push(new t.Vector2(s.x,s.y)))}}return i}(e,r.points).forEach((t=>{s.push({identifier:r.identifier,isCW:r.isCW,point:t})}))})),s.sort(((t,e)=>t.point.x-e.point.x)),s}([new t.Vector2(n,a.y),new t.Vector2(i,a.y)],e.boundingBox,r);c.sort(((t,e)=>t.point.x-e.point.x));const l=[],u=[];c.forEach((t=>{t.identifier===e.identifier?l.push(t):u.push(t)}));const f=l[0].point.x,y=[];let h=0;for(;h<u.length&&u[h].point.x<f;)y.length>0&&y[y.length-1]===u[h].identifier?y.pop():y.push(u[h].identifier),h++;if(y.push(e.identifier),"evenodd"===s){const t=y.length%2==0,r=y[y.length-2];return{identifier:e.identifier,isHole:t,for:r}}if("nonzero"===s){let t=!0,n=null,o=null;for(let e=0;e<y.length;e++){const i=y[e];t?(o=r[i].isCW,t=!1,n=i):o!==r[i].isCW&&(o=r[i].isCW,t=!0)}return{identifier:e.identifier,isHole:t,for:n}}console.warn('fill-rule: "'+s+'" is currently not implemented.')}(r,c,s,a,e.userData?e.userData.style.fillRule:void 0))),u=[];return c.forEach((e=>{if(!l[e.identifier].isHole){const r=new t.Shape;r.curves=e.curves,l.filter((t=>t.isHole&&t.for===e.identifier)).forEach((e=>{const n=c[e.identifier],o=new t.Path;o.curves=n.curves,r.holes.push(o)})),u.push(r)}})),u}static getStrokeStyle(t,e,r,n,o){return{strokeColor:e=void 0!==e?e:"#000",strokeWidth:t=void 0!==t?t:1,strokeLineJoin:r=void 0!==r?r:"miter",strokeLineCap:n=void 0!==n?n:"butt",strokeMiterLimit:o=void 0!==o?o:4}}static pointsToStroke(e,n,o,i){const s=[],a=[],c=[];if(0===r.pointsToStrokeWithBuffers(e,n,o,i,s,a,c))return null;const l=new t.BufferGeometry;return l.setAttribute("position",new t.Float32BufferAttribute(s,3)),l.setAttribute("normal",new t.Float32BufferAttribute(a,3)),l.setAttribute("uv",new t.Float32BufferAttribute(c,2)),l}static pointsToStrokeWithBuffers(e,r,n,o,i,s,a,c){const l=new t.Vector2,u=new t.Vector2,f=new t.Vector2,y=new t.Vector2,h=new t.Vector2,p=new t.Vector2,d=new t.Vector2,m=new t.Vector2,b=new t.Vector2,g=new t.Vector2,x=new t.Vector2,A=new t.Vector2,v=new t.Vector2,w=new t.Vector2,k=new t.Vector2,T=new t.Vector2,M=new t.Vector2;n=void 0!==n?n:12,o=void 0!==o?o:.001,c=void 0!==c?c:0;const E=(e=function(t){let e=!1;for(let r=1,n=t.length-1;r<n;r++)if(t[r].distanceTo(t[r+1])<o){e=!0;break}if(!e)return t;const r=[];r.push(t[0]);for(let e=1,n=t.length-1;e<n;e++)t[e].distanceTo(t[e+1])>=o&&r.push(t[e]);return r.push(t[t.length-1]),r}(e)).length;if(E<2)return 0;const S=e[0].equals(e[E-1]);let P,I,V=e[0];const C=r.strokeWidth/2,G=1/(E-1);let R,B,N,O,L=0,H=!1,z=0,q=3*c,U=2*c;W(e[0],e[1],l).multiplyScalar(C),m.copy(e[0]).sub(l),b.copy(e[0]).add(l),g.copy(m),x.copy(b);for(let t=1;t<E;t++){P=e[t],I=t===E-1?S?e[1]:void 0:e[t+1];const n=l;if(W(V,P,n),f.copy(n).multiplyScalar(C),A.copy(P).sub(f),v.copy(P).add(f),R=L+G,B=!1,void 0!==I){W(P,I,u),f.copy(u).multiplyScalar(C),w.copy(P).sub(f),k.copy(P).add(f),N=!0,f.subVectors(I,V),n.dot(f)<0&&(N=!1),1===t&&(H=N),f.subVectors(I,P),f.normalize();const e=Math.abs(n.dot(f));if(e>Number.EPSILON){const t=C/e;f.multiplyScalar(-t),y.subVectors(P,V),h.copy(y).setLength(t).add(f),T.copy(h).negate();const n=h.length(),o=y.length();y.divideScalar(o),p.subVectors(I,P);const i=p.length();switch(p.divideScalar(i),y.dot(T)<o&&p.dot(T)<i&&(B=!0),M.copy(h).add(P),T.add(P),O=!1,B?N?(k.copy(T),v.copy(T)):(w.copy(T),A.copy(T)):F(),r.strokeLineJoin){case"bevel":X(N,B,R);break;case"round":J(N,B),N?D(P,A,w,R,0):D(P,k,v,R,1);break;default:const t=C*r.strokeMiterLimit/n;if(t<1){if("miter-clip"!==r.strokeLineJoin){X(N,B,R);break}J(N,B),N?(p.subVectors(M,A).multiplyScalar(t).add(A),d.subVectors(M,w).multiplyScalar(t).add(w),j(A,R,0),j(p,R,0),j(P,R,.5),j(P,R,.5),j(p,R,0),j(d,R,0),j(P,R,.5),j(d,R,0),j(w,R,0)):(p.subVectors(M,v).multiplyScalar(t).add(v),d.subVectors(M,k).multiplyScalar(t).add(k),j(v,R,1),j(p,R,1),j(P,R,.5),j(P,R,.5),j(p,R,1),j(d,R,1),j(P,R,.5),j(d,R,1),j(k,R,1))}else B?(N?(j(b,L,1),j(m,L,0),j(M,R,0),j(b,L,1),j(M,R,0),j(T,R,1)):(j(b,L,1),j(m,L,0),j(M,R,1),j(m,L,0),j(T,R,0),j(M,R,1)),N?w.copy(M):k.copy(M)):N?(j(A,R,0),j(M,R,0),j(P,R,.5),j(P,R,.5),j(M,R,0),j(w,R,0)):(j(v,R,1),j(M,R,1),j(P,R,.5),j(P,R,.5),j(M,R,1),j(k,R,1)),O=!0}}else F()}else F();S||t!==E-1||Y(e[0],g,x,N,!0,L),L=R,V=P,m.copy(w),b.copy(k)}if(S){if(B&&i){let t=M,e=T;H!==N&&(t=T,e=M),N?(O||H)&&(e.toArray(i,0),e.toArray(i,9),O&&t.toArray(i,3)):!O&&H||(e.toArray(i,3),e.toArray(i,9),O&&t.toArray(i,0))}}else Y(P,A,v,N,!1,R);return z;function W(t,e,r){return r.subVectors(e,t),r.set(-r.y,r.x).normalize()}function j(t,e,r){i&&(i[q]=t.x,i[q+1]=t.y,i[q+2]=0,s&&(s[q]=0,s[q+1]=0,s[q+2]=1),q+=3,a&&(a[U]=e,a[U+1]=r,U+=2)),z+=3}function D(t,e,r,o,i){l.copy(e).sub(t).normalize(),u.copy(r).sub(t).normalize();let s=Math.PI;const a=l.dot(u);Math.abs(a)<1&&(s=Math.abs(Math.acos(a))),s/=n,f.copy(e);for(let e=0,r=n-1;e<r;e++)y.copy(f).rotateAround(t,s),j(f,o,i),j(y,o,i),j(t,o,.5),f.copy(y);j(y,o,i),j(r,o,i),j(t,o,.5)}function F(){j(b,L,1),j(m,L,0),j(A,R,0),j(b,L,1),j(A,R,1),j(v,R,0)}function X(t,e,r){e?t?(j(b,L,1),j(m,L,0),j(A,R,0),j(b,L,1),j(A,R,0),j(T,R,1),j(A,r,0),j(w,r,0),j(T,r,.5)):(j(b,L,1),j(m,L,0),j(v,R,1),j(m,L,0),j(T,R,0),j(v,R,1),j(v,r,1),j(k,r,0),j(T,r,.5)):t?(j(A,r,0),j(w,r,0),j(P,r,.5)):(j(v,r,1),j(k,r,0),j(P,r,.5))}function J(t,e){e&&(t?(j(b,L,1),j(m,L,0),j(A,R,0),j(b,L,1),j(A,R,0),j(T,R,1),j(A,L,0),j(P,R,.5),j(T,R,1),j(P,R,.5),j(w,L,0),j(T,R,1)):(j(b,L,1),j(m,L,0),j(v,R,1),j(m,L,0),j(T,R,0),j(v,R,1),j(v,L,1),j(T,R,0),j(P,R,.5),j(P,R,.5),j(T,R,0),j(k,L,1)))}function Y(t,e,n,o,s,a){switch(r.strokeLineCap){case"round":s?D(t,n,e,a,.5):D(t,e,n,a,.5);break;case"square":if(s)l.subVectors(e,t),u.set(l.y,-l.x),f.addVectors(l,u).add(t),y.subVectors(u,l).add(t),o?(f.toArray(i,3),y.toArray(i,0),y.toArray(i,9)):(f.toArray(i,3),f.toArray(i,9),y.toArray(i,0));else{l.subVectors(n,t),u.set(l.y,-l.x),f.addVectors(l,u).add(t),y.subVectors(u,l).add(t);const e=i.length;o?(f.toArray(i,e-3),y.toArray(i,e-6),y.toArray(i,e-12)):(f.toArray(i,e-6),y.toArray(i,e-3),y.toArray(i,e-12))}}}}}function i(e){let r,n,o,i=-1,s=0;for(let t=0;t<e.length;++t){const a=e[t];if(a.isInterleavedBufferAttribute)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. InterleavedBufferAttributes are not supported."),null;if(void 0===r&&(r=a.array.constructor),r!==a.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(void 0===n&&(n=a.itemSize),n!==a.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(void 0===o&&(o=a.normalized),o!==a.normalized)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;if(-1===i&&(i=a.gpuType),i!==a.gpuType)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."),null;s+=a.array.length}const a=new r(s);let c=0;for(let t=0;t<e.length;++t)a.set(e[t].array,c),c+=e[t].array.length;const l=new t.BufferAttribute(a,n,o);return void 0!==i&&(l.gpuType=i),l}var s=function(e,n,o){return new Promise((function(s,a){(new r).load(e,(function(e){for(var r=e.paths,a=[],c=0;c<r.length;c++){var l=r[c].toShapes(!0),u=new t.ExtrudeGeometry(l,{depth:n*(1/o),bevelEnabled:!1});a.push(u)}var f=function(e,r=!1){const n=null!==e[0].index,o=new Set(Object.keys(e[0].attributes)),s=new Set(Object.keys(e[0].morphAttributes)),a={},c={},l=e[0].morphTargetsRelative,u=new t.BufferGeometry;let f=0;for(let t=0;t<e.length;++t){const i=e[t];let y=0;if(n!==(null!==i.index))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+t+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const e in i.attributes){if(!o.has(e))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+t+'. All geometries must have compatible attributes; make sure "'+e+'" attribute exists among all geometries, or in none of them.'),null;void 0===a[e]&&(a[e]=[]),a[e].push(i.attributes[e]),y++}if(y!==o.size)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+t+". Make sure all geometries have the same number of attributes."),null;if(l!==i.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+t+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const e in i.morphAttributes){if(!s.has(e))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+t+".  .morphAttributes must be consistent throughout all geometries."),null;void 0===c[e]&&(c[e]=[]),c[e].push(i.morphAttributes[e])}if(r){let e;if(n)e=i.index.count;else{if(void 0===i.attributes.position)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+t+". The geometry must have either an index or a position attribute"),null;e=i.attributes.position.count}u.addGroup(f,e,t),f+=e}}if(n){let t=0;const r=[];for(let n=0;n<e.length;++n){const o=e[n].index;for(let e=0;e<o.count;++e)r.push(o.getX(e)+t);t+=e[n].attributes.position.count}u.setIndex(r)}for(const t in a){const e=i(a[t]);if(!e)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+t+" attribute."),null;u.setAttribute(t,e)}for(const t in c){const e=c[t][0].length;if(0===e)break;u.morphAttributes=u.morphAttributes||{},u.morphAttributes[t]=[];for(let r=0;r<e;++r){const e=[];for(let n=0;n<c[t].length;++n)e.push(c[t][n][r]);const n=i(e);if(!n)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+t+" morphAttribute."),null;u.morphAttributes[t].push(n)}}return u}(a);f.scale(o,o,o),s(f)}),void 0,a)}))}})(),o})()));